#include <iostream>
#include <vector>
#include <time.h>
#include <fstream>
#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <chrono>

using namespace std;

float pi=3.14159;

//arm lengths
float l1 = 3.0;
float l2 = 2.0;
float l3 = 2.0;

//start and end points
float xs = -2;
float ys = 1;
float zs = 0;

float xe = 2;
float ye = 5;
float ze = 0;
vector <float> start_point { xs, ys, zs };
vector <float> end_point { xe, ye, ze };


struct state{
    float theta1;
    float theta2;
    float theta3;
    float x1;
    float y1;
    float z1;
    
    float x2;
    float y2;
    float z2 ;
    
    float x3;
    float y3;
    float z3;
    float time;
    
    state(float mtheta1, float mtheta2, float mtheta3){
        theta1 = mtheta1;
        theta2 = mtheta2;
        theta3 = mtheta3;
        x1 = 0;
        y1 = l1;
        z1 = 0;
    
        x2 = l2*sin(theta2)*cos(theta1);
        y2 = l1 - l2*cos(theta2);
        z2 = l2*sin(theta2)*sin(theta1);
    
        x3 = ( l2*sin(theta2) - l3*sin(theta2+theta3) )*cos(theta1);
        y3 = l1 - l2*cos(theta2) + l3*cos(theta2+theta3);
        z3 = ( l2*sin(theta2) - l3*sin(theta2+theta3) )*sin(theta1);
    }
    
    state(){
        theta1 = 0.0;
        theta2 = 0.0;
        theta3 = 0.0;
        time = 0.0;
    }
    
        //position of the end points (x1,y1,z1)   (x2,y2,z2)  (x3,y3,z3)
    
    void display_state(){
        cout << "\nStates-------------- at time: " << time <<"\n";
        cout << "Angles are: (" << theta1 << "\t" <<theta2 << "\t" << theta3 << ")" <<endl;
        cout << "Point positions are :\n" << "Point 1: ( " << x1 << " , " << y1 << " , " << z1 << " )" <<
            "\tPoint 2: ( " << x2 << " , " << y2 << " , " << z2 << " )\t";
        cout << "Point 3: ( " << x3 << " , " << y3 << " , " << z3 << " )" << endl;
    }
};

vector <vector <vector <float>>> obstacle_vector{};

//function definitions
vector <float> get_thetas (const vector <float> &point);  //-----> inverse kinematics
float theta_vector(float p1x, float p1y, float p2x, float p2y);  //-----> calculate angle (theta) value
void generate_c_cpace();  //----------------------------------------> generates c space for the manipulator
vector <float> get_plane_parameters(int p, int q, int r, int i);

int main(){
    obstacle_vector={ {{5,0,5},{5,0,-5},{-5,0,-5},{-5,0,5},{5,-5,5},{5,-5,-5},{-5,-5,-5},{-5,-5,5}} };
    
    cout << "Starts now" << endl;
    state newstate;
    newstate.display_state();
    
    vector <float> temp_thetas{};
    cout << "\nStart point "<< start_point.at(0) <<"\t"<< start_point.at(1) <<"\t"<< start_point.at(2) <<"\n";
    temp_thetas = get_thetas(start_point);
    state initial_state(temp_thetas.at(0), temp_thetas.at(1), temp_thetas.at(2) );
    cout << "\nEnd point"<< end_point.at(0) <<"\t"<< end_point.at(1) << "\t" << end_point.at(2) <<"\n";
    temp_thetas = get_thetas(end_point);
    state final_state(temp_thetas.at(0), temp_thetas.at(1), temp_thetas.at(2) );
    
    cout<<"\nThe initial_states are: \n";
    initial_state.display_state();
    cout<<"\n---------------------------\n";
    cout<<"\nThe final states are: \n";
    final_state.display_state();
    
    //generate c-space
    generate_c_cpace();
    
    return 0;
}

void generate_c_cpace(){
    vector <vector <vector <float>>> plane_parameters {};
    cout<<"\n\nGenerating C-space:\n\n";
    
    //get plane equations for all the obstalces (cubes, cuboids)
    for(int i=0 ; i<obstacle_vector.size() ; i++){
        vector <vector <float>> temp_vec{};
        temp_vec.push_back( get_plane_parameters(1,2,3,i) );
        temp_vec.push_back( get_plane_parameters(5,6,7,i) );
        temp_vec.push_back( get_plane_parameters(5,6,2,i) );
        temp_vec.push_back( get_plane_parameters(8,7,3,i) );
        temp_vec.push_back( get_plane_parameters(5,1,4,i) );
        temp_vec.push_back( get_plane_parameters(6,2,3,i) );
        plane_parameters.push_back(temp_vec);
    }
    
    cout<<"\n\nThe plane parameters are:\n";
    for(int i=0 ; i<plane_parameters.size() ; i++){
        for(int j=0 ; j<plane_parameters.at(i).size() ; j++){
            for(int k=0 ; k<plane_parameters.at(i).at(j).size() ; k++)
                cout<<plane_parameters.at(i).at(j).at(k)<<" ";
            cout<<endl;
        }
        cout<<endl;
    }
    cout<<endl<<endl;
    
    for(int i=0 ; i<360 ; i++){
        for(int j=0 ; j<360 ; j++){
            for(int k=0 ; k<360 ; k++){
                //check collision for all angles tomorrow
                //must take 2 hrs, but do it fast
            }
        }
    }
    
}

vector <float> get_plane_parameters(int p, int q, int r, int i){
    
    float x1 = obstacle_vector.at(i).at(p-1).at(0);
    float y1 = obstacle_vector.at(i).at(p-1).at(1);
    float z1 = obstacle_vector.at(i).at(p-1).at(2);
   
    float x2 = obstacle_vector.at(i).at(q-1).at(0);
    float y2 = obstacle_vector.at(i).at(q-1).at(1);
    float z2 = obstacle_vector.at(i).at(q-1).at(2);

    float x3 = obstacle_vector.at(i).at(r-1).at(0);
    float y3 = obstacle_vector.at(i).at(r-1).at(1);
    float z3 = obstacle_vector.at(i).at(r-1).at(2);
 
    float a = ( (y2-y1)*(z3-z1) - (y3-y1)*(z2-z1) );
    float b = ( -1*(x2-x1)*(z3-z1) + (x3-x1)*(z2-z1) );
    float c = ( (x2-x1)*(y3-y1) - (x3-x1)*(y2-y1) );
    float d = ( -a*x1 - b*y1 - c*z1 );
    
    vector <float> plane_parms {a,b,c,d};
    return (plane_parms);
}

vector <float> get_thetas (const vector <float> &point) {
    float x3 = point.at(0);
    float y3 = point.at(1);
    float z3 = point.at(2);
    
    float theta_1 = theta_vector(0,0,x3,z3);
    
    //calculate theta_2
    float x1 = 0;
    float y1 = l1;
    float z1 = 0;
    
    x1 = sqrt(x1*x1 + z1*z1);
    //y1 = y1;
    float x2 = sqrt(x3*x3 + z3*z3);
    float y2 = y3;
    
    float a = ( (l2*l2-l3*l3) - (x1*x1 - x2*x2) - (y1*y1 - y2*y2) ) / (2*y2-2*y1);
    float b = (2*x2 - 2*x1) / (2*y2 - 2*y1);
    float as = ( 1 + b*b ); cout<<"as\t"<<as<<endl;
    float bs = ( -2*x1 - 2*b*(a-y1) );  cout<<"bs\t"<<bs<<endl;
    float cs = ( x1*x1 + (a-y1)*(a-y1) - l2*l2 );  cout<<"cs\t"<<cs<<endl;
    
    float x = (-bs - sqrt( bs*bs - 4*as*cs ) ) / (2*as);
    float y = a - b*x;
    cout << "\nIntersection points: " << x << "\t" << y << endl;
    
    float theta_2 = theta_vector(x1,y1,x,y); cout<<"\nTheta 2 is "<<theta_2<<endl;   //--------------------------------------- not proper, but still works
    if( theta_2 <= (pi/2 + 0.01) )
        theta_2 += (pi/2);
    if( theta_2 >= (3*pi/2-0.001) )
        theta_2 -= 3*pi/2 - 0.001;
//    if ( (0 < theta_2) && (theta_2 < (3*pi/2)) ){
//        theta_2 += pi/2;
//    }
//    //if ( 4.7123 <= theta_2 < 6.28319){
//    else{
//        theta_2 -= (3*pi/2);
//    }
    
    //calculate theta_3
    float theta_3 = theta_vector(x,y,x2,y2) - theta_vector(x1,y1,x,y) + pi;
    if (theta_3 < 0)
        theta_3 += 2*pi;
    
    vector <float> thetas = {theta_1, theta_2, theta_3};
    cout<<"\nThetas: "<<theta_1<<"\t"<<theta_2<<"\t"<<theta_3<<endl;
    return thetas;
}

float theta_vector(float p1x, float p1y, float p2x, float p2y){
    if(((p2y-p1y)>=0)&&((p2x-p1x)>=0))             //1st quadrant
        return (atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)>=0)&&((p2x-p1x)<0))         //2nd quadrant
        return (3.14159+atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)<0)&&((p2x-p1x)<0))           //3rd quadrant
        return (3.14159+atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)<0)&&((p2x-p1x)>=0))          //4th quadrant
        return ((2*3.14159)+atan((p2y-p1y)/(p2x-p1x)));
    else
        return (0);
}
