#include <iostream>
#include <vector>
#include <time.h>
#include <fstream>
#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <chrono>

using namespace std;

float pi=3.14159;

//arm lengths
float l1 = 3.0;
float l2 = 2.0;
float l3 = 2.0;

//start and end points
float xs = -2;
float ys = 1;
float zs = 0;

float xe = 2;
float ye = 5;
float ze = 0;
vector <float> start_point { xs, ys, zs };
vector <float> end_point { xe, ye, ze };


struct state{
    float theta1;
    float theta2;
    float theta3;
    float x1;
    float y1;
    float z1;
    
    float x2;
    float y2;
    float z2 ;
    
    float x3;
    float y3;
    float z3;
    float time;
    
    state(float mtheta1, float mtheta2, float mtheta3){
        theta1 = mtheta1;
        theta2 = mtheta2;
        theta3 = mtheta3;
        x1 = 0;
        y1 = l1;
        z1 = 0;
    
        x2 = l2*sin(theta2)*cos(theta1);
        y2 = l1 - l2*cos(theta2);
        z2 = l2*sin(theta2)*sin(theta1);
    
        x3 = ( l2*sin(theta2) - l3*sin(theta2+theta3) )*cos(theta1);
        y3 = l1 - l2*cos(theta2) + l3*cos(theta2+theta3);
        z3 = ( l2*sin(theta2) - l3*sin(theta2+theta3) )*sin(theta1);
    }
    
    state(){
        theta1 = 0.0;
        theta2 = 0.0;
        theta3 = 0.0;
        time = 0.0;
    }
    
        //position of the end points (x1,y1,z1)   (x2,y2,z2)  (x3,y3,z3)
    
    void display_state(){
        cout << "\nStates-------------- at time: " << time <<"\n";
        cout << "Angles are: (" << theta1 << "\t" <<theta2 << "\t" << theta3 << ")" <<endl;
        cout << "Point positions are :\n" << "Point 1: ( " << x1 << " , " << y1 << " , " << z1 << " )" <<
            "\tPoint 2: ( " << x2 << " , " << y2 << " , " << z2 << " )\t";
        cout << "Point 3: ( " << x3 << " , " << y3 << " , " << z3 << " )" << endl;
    }
    
//    int check_state( vector <vector <vector <float>>> plane_parameters ){
//       if(link1_link3_intersection()==1){
//           return 0;                  //indicates intersection
//       }
//       else{
//          for( int i=0; i<plane_parameters.size; i++){
//              for( int j=0; j<plane_parameters.at(i).size; j++){
//                  float s1 = plane_parameters.at(i).at(j).(0)*x2 + plane_parameters.at(i).at(j).(1)*y2 + plane_parameters.at(i).at(j).(2)*z2 + plane_parameters.at(i).at(j).(3);
//                  float s2 = plane_parameters.at(i).at(j).(0)*x3 + plane_parameters.at(i).at(j).(1)*y3 + plane_parameters.at(i).at(j).(2)*z3 + plane_parameters.at(i).at(j).(3);
//                  if ( (s1*s2) < 0 )
//                  //check for intersection of line on plane
//                  {
//                  }
//                  else
//                      return 0;
//              }
//          } 
//       }
//    }

    float projection_vector(const vector <float> &a, const vector <float> &b){
        float x{};
        for(int i=0; i< a.size(); i++){
            x += (a.at(i)) * (b.at(i)) ;
        }
        
        float y{};
        for(int i=0; i< a.size(); i++){
            y += a.at(i)*a.at(i);
        }
        y = sqrt(y);
        
        x /= y;
        return x;
    }
    
    float euclid_dist(const vector <float> &a, const vector <float> &b){
        float x{};
        for(int i=0; i< a.size(); i++){
            x += (a.at(i) - b.at(i)) * (a.at(i) - b.at(i)) ;
        }
        x = sqrt(x);
        return x;
    }
    
    int intersection_cond_1d( const vector <float> &a, const vector <float> &b2, const vector <float> &b3, const vector <float> &p1, const vector <float> &p2){
            float d1 = projection_vector(a,b3); 
            float d2 = projection_vector(a,b2);
            float d = euclid_dist (p1,p2);
            if( ( 0<d1 && d1<d ) || ( 0<d2 && d2<d ) )
                return 1;
            else 
                return 0;
    }
    
    int check_state ( const vector <vector <vector <float>>> &plane_parameters ){
        if(link1_link3_intersection()==1){
           //cout<<"\n\nLink 1 and link 3 intersect here: \n";
           //display_state();//-------------------------------------------------display_state
           return 1;                  //indicates intersection
       }
       
       else{
           //check for each obstalce
           int count_ok{};
           for( int i=0; i<plane_parameters.size() ; i++ ){
               int count = 0;
               vector <float> a1 { (plane_parameters.at(i).at(5).at(0) - plane_parameters.at(i).at(6).at(0)) , (plane_parameters.at(i).at(5).at(1) - plane_parameters.at(i).at(6).at(1)) , (plane_parameters.at(i).at(5).at(2) - plane_parameters.at(i).at(6).at(2)) }; 
               vector <float> a2 { (plane_parameters.at(i).at(7).at(0) - plane_parameters.at(i).at(6).at(0)) , (plane_parameters.at(i).at(7).at(1) - plane_parameters.at(i).at(6).at(1)) , (plane_parameters.at(i).at(7).at(2) - plane_parameters.at(i).at(6).at(2)) };
               vector <float> a3 { (plane_parameters.at(i).at(2).at(0) - plane_parameters.at(i).at(6).at(0)) , (plane_parameters.at(i).at(2).at(1) - plane_parameters.at(i).at(6).at(1)) , (plane_parameters.at(i).at(2).at(2) - plane_parameters.at(i).at(6).at(2)) };
               vector <float> b3 { x3 - plane_parameters.at(i).at(6).at(0), y3 - plane_parameters.at(i).at(6).at(1) , z3 - plane_parameters.at(i).at(6).at(2)};
               vector <float> b2 { x2 - plane_parameters.at(i).at(6).at(0), y2 - plane_parameters.at(i).at(6).at(1) , z2 - plane_parameters.at(i).at(6).at(2)};
               vector <float> b1 { x1 - plane_parameters.at(i).at(6).at(0), y1 - plane_parameters.at(i).at(6).at(1) , z1 - plane_parameters.at(i).at(6).at(2)};
               
               count += intersection_cond_1d(a1,b2,b3,plane_parameters.at(i).at(5),plane_parameters.at(i).at(6));
                
               count += intersection_cond_1d(a2,b2,b3,plane_parameters.at(i).at(7),plane_parameters.at(i).at(6));
                   
               count += intersection_cond_1d(a3,b2,b3,plane_parameters.at(i).at(2),plane_parameters.at(i).at(6));
                   
               if( count==3 ) //then link 3 intersects with obstacle
               break;
               
               else{
                count=0;
                
                count += intersection_cond_1d(a1,b1,b2,plane_parameters.at(i).at(5),plane_parameters.at(i).at(6));
                
                count += intersection_cond_1d(a2,b1,b2,plane_parameters.at(i).at(7),plane_parameters.at(i).at(6));
                   
                count += intersection_cond_1d(a3,b1,b2,plane_parameters.at(i).at(2),plane_parameters.at(i).at(6));
                
                if( count==3 ) //then link 2 intersects with obstacle
                 break;
                else
                    count_ok++;
               }
           }
           if( count_ok == plane_parameters.size() )
               return 0;   // no intersection
           else
               return 1;  //indicates intersection
       }
    }
    
    int link1_link3_intersection(){
     float alpha1{10000000000.0}, alpha2{10000000000.0};
        if(x3 != x2){  //else alpha1 can take any value-------------------------------------------------------------------------------------------------------------------
            alpha1 = (-x2) / (x3-x2);
        }
        
        if(z3 != z2){  //else alpha2 can take any value--------------------------------------------------------------------------------------------------------------------
            alpha2 = (-z2) / (z3-z2);
        }
        
        if( (alpha1 == alpha2) && (alpha1 > 0) && (alpha1 < 1) ){
            if( ( (y2 + alpha1*(y3-y2)) > 0 ) && ( (y2 + alpha1*(y3-y2)) < l1 ) )
                return 1;                                   //indicates intersection
            else
                return 0;
        }
        else
            return 0;
    }
    
    ~state() {}
};

vector <vector <vector <float>>> obstacle_vector{};

//function definitions
vector <float> get_thetas (const vector <float> &point);  //-----> inverse kinematics
float theta_vector(float p1x, float p1y, float p2x, float p2y);  //-----> calculate angle (theta) value
vector <vector <vector <int>>> generate_c_cpace();  //----------------------------------------> generates c space for the manipulator
vector <float> get_plane_parameters(int p, int q, int r, int i);

int main(){
//    obstacle_vector={ {{5,0,5},{5,0,-5},{-5,0,-5},{-5,0,5},{5,-5,5},{5,-5,-5},{-5,-5,-5},{-5,-5,5}} };
//    obstacle_vector={ {{5,8,5},{5,8,-5},{-5,8,-5},{-5,8,5},{5,5,5},{5,5,-5},{-5,5,-5},{-5,5,5}} };
    obstacle_vector={ {{5,3,5},{5,3,-5},{-5,3,-5},{-5,3,5},{5,-5,5},{5,-5,-5},{-5,-5,-5},{-5,-5,5}} };
    
    //cout << "Starts now" << endl;
    state newstate;
    newstate.display_state();
    
    vector <float> temp_thetas{};
    cout << "\nStart point "<< start_point.at(0) <<"\t"<< start_point.at(1) <<"\t"<< start_point.at(2) <<"\n";
    temp_thetas = get_thetas(start_point);
    state initial_state(temp_thetas.at(0), temp_thetas.at(1), temp_thetas.at(2) );
    cout << "\nEnd point"<< end_point.at(0) <<"\t"<< end_point.at(1) << "\t" << end_point.at(2) <<"\n";
    temp_thetas = get_thetas(end_point);
    state final_state(temp_thetas.at(0), temp_thetas.at(1), temp_thetas.at(2) );
    
    cout<<"\nThe initial_states are: \n";
    initial_state.display_state();
    cout<<"\n---------------------------\n";
    cout<<"\nThe final states are: \n";
    final_state.display_state();
    
    //generate c-space
    vector <vector <vector <int>>> c_space = generate_c_cpace();
    cout<<"\n\n\n*********   C SPACE GENERATED   *******************\n\n\n";
    
    ofstream myfile;
    myfile.open ("P1_Cspace2s.csv");
    for(int i=0; i<c_space.size(); i++){
        for(int j=0; j<c_space.at(i).size(); j++){
            for(int k=0; k<c_space.at(i).at(j).size(); k++){
                if( c_space.at(i).at(j).at(k)==1 )
                   myfile<<i<<","<<j<<","<<k;
                myfile<<endl;
            }
        }
        myfile<<endl;
    }
    myfile.close();
    
    return 0;
}

vector <vector <vector <int>>> generate_c_cpace(){
    vector <vector <vector <float>>> plane_parameters {};
//  vector <vector <vector <int>>> c_space_obstacles (180, vector <vector <int>>(180, vector <int> (180) ) );
    vector <vector <vector <int>>> c_space_obstacles {};
    cout<<"\n\nGenerating C-space:\n\n";
    
    //get plane equations for all the obstalces (cubes, cuboids)
    for(int i=0 ; i<obstacle_vector.size() ; i++){
        vector <vector <float>> temp_vec{};
        temp_vec.push_back( get_plane_parameters(1,2,3,i) );
        temp_vec.push_back( get_plane_parameters(5,6,7,i) );
        temp_vec.push_back( get_plane_parameters(5,6,2,i) );
        temp_vec.push_back( get_plane_parameters(8,7,3,i) );
        temp_vec.push_back( get_plane_parameters(5,1,4,i) );
        temp_vec.push_back( get_plane_parameters(6,2,3,i) );
        plane_parameters.push_back(temp_vec);
    }
    
    cout<<"\n\nThe plane parameters are:\n";
    for(int i=0 ; i<plane_parameters.size() ; i++){
        for(int j=0 ; j<plane_parameters.at(i).size() ; j++){
            for(int k=0 ; k<plane_parameters.at(i).at(j).size() ; k++)
                cout<<plane_parameters.at(i).at(j).at(k)<<" ";
            cout<<endl;
        }
        cout<<endl;
    }
    cout<<endl<<endl;
    
    for(int i=0 ; i<360 ; i+=2){   //-------> for theta1
        vector <vector <int>> temp2_vector{};
        for(int j=0 ; j<360 ; j+=2){    //-------> for theta2
            
            vector <int> temp_vector{};
            for(int k=0 ; k<360 ; k+=2){   //-------> for theta3
                
                //check collision for all angles tomorrow
                //must take 2 hrs, but do it fast
                state check_this_state ((i*pi/180),(j*pi/180),(k*pi/180));
                if( check_this_state.check_state(obstacle_vector) == 1 ){
                   temp_vector.push_back(1);
                   //c_space_obstacles.at(i/2).at(j/2).at(k/2) = 1;   //intersection happens
                   //check_this_state.display_state();//-------------------------------------------------display_state
                }
                else
                    temp_vector.push_back(0);
                    //c_space_obstacles.at(i).at(j).at(k) = 0; 
            }
            temp2_vector.push_back(temp_vector);
        }
        c_space_obstacles.push_back(temp2_vector);
        cout<<"Loading..."<<i<<endl;
    }
    
    return c_space_obstacles;
}

vector <float> get_plane_parameters(int p, int q, int r, int i){
    
    float x1 = obstacle_vector.at(i).at(p-1).at(0);
    float y1 = obstacle_vector.at(i).at(p-1).at(1);
    float z1 = obstacle_vector.at(i).at(p-1).at(2);
   
    float x2 = obstacle_vector.at(i).at(q-1).at(0);
    float y2 = obstacle_vector.at(i).at(q-1).at(1);
    float z2 = obstacle_vector.at(i).at(q-1).at(2);

    float x3 = obstacle_vector.at(i).at(r-1).at(0);
    float y3 = obstacle_vector.at(i).at(r-1).at(1);
    float z3 = obstacle_vector.at(i).at(r-1).at(2);
 
    float a = ( (y2-y1)*(z3-z1) - (y3-y1)*(z2-z1) );
    float b = ( -1*(x2-x1)*(z3-z1) + (x3-x1)*(z2-z1) );
    float c = ( (x2-x1)*(y3-y1) - (x3-x1)*(y2-y1) );
    float d = ( -a*x1 - b*y1 - c*z1 );
    
    vector <float> plane_parms {a,b,c,d};
    return (plane_parms);
}

vector <float> get_thetas (const vector <float> &point) {
    float x3 = point.at(0);
    float y3 = point.at(1);
    float z3 = point.at(2);
    
    float theta_1 = theta_vector(0,0,x3,z3);
    
    //calculate theta_2
    float x1 = 0;
    float y1 = l1;
    float z1 = 0;
    
    x1 = sqrt(x1*x1 + z1*z1);
    //y1 = y1;
    float x2 = sqrt(x3*x3 + z3*z3);
    float y2 = y3;
    
    float a = ( (l2*l2-l3*l3) - (x1*x1 - x2*x2) - (y1*y1 - y2*y2) ) / (2*y2-2*y1);
    float b = (2*x2 - 2*x1) / (2*y2 - 2*y1);
    float as = ( 1 + b*b ); cout<<"as\t"<<as<<endl;
    float bs = ( -2*x1 - 2*b*(a-y1) );  cout<<"bs\t"<<bs<<endl;
    float cs = ( x1*x1 + (a-y1)*(a-y1) - l2*l2 );  cout<<"cs\t"<<cs<<endl;
    
    float x = (-bs - sqrt( bs*bs - 4*as*cs ) ) / (2*as);
    float y = a - b*x;
    cout << "\nIntersection points: " << x << "\t" << y << endl;
    
    float theta_2 = theta_vector(x1,y1,x,y); cout<<"\nTheta 2 is "<<theta_2<<endl;   //--------------------------------------- not proper, but still works
    if( theta_2 <= (pi/2 + 0.01) )
        theta_2 += (pi/2);
    if( theta_2 >= (3*pi/2-0.001) )
        theta_2 -= 3*pi/2 - 0.001;
//    if ( (0 < theta_2) && (theta_2 < (3*pi/2)) ){
//        theta_2 += pi/2;
//    }
//    //if ( 4.7123 <= theta_2 < 6.28319){
//    else{
//        theta_2 -= (3*pi/2);
//    }
    
    //calculate theta_3
    float theta_3 = theta_vector(x,y,x2,y2) - theta_vector(x1,y1,x,y) + pi;
    if (theta_3 < 0)
        theta_3 += 2*pi;
    
    vector <float> thetas = {theta_1, theta_2, theta_3};
    cout<<"\nThetas: "<<theta_1<<"\t"<<theta_2<<"\t"<<theta_3<<endl;
    return thetas;
}

float theta_vector(float p1x, float p1y, float p2x, float p2y){
    if(((p2y-p1y)>=0)&&((p2x-p1x)>=0))             //1st quadrant
        return (atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)>=0)&&((p2x-p1x)<0))         //2nd quadrant
        return (3.14159+atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)<0)&&((p2x-p1x)<0))           //3rd quadrant
        return (3.14159+atan((p2y-p1y)/(p2x-p1x)));
    else if(((p2y-p1y)<0)&&((p2x-p1x)>=0))          //4th quadrant
        return ((2*3.14159)+atan((p2y-p1y)/(p2x-p1x)));
    else
        return (0);
}
